{
    "docs": [
        {
            "location": "/", 
            "text": "Ginkgo4j\n\n\nA Java BDD Testing Framework\n\n\nGinkgo4j\n is a BDD-style Java testing framework built to help you efficiently write expressive and comprehensive tests.\n\n\nGinkgo4j was inspired by its namesake \nGinkgo\n.  It mirrors frameworks from other languages like RSpec in Ruby.  All of these framework provide a very simply DSL that the developer can use in his test to build up a described context with closures.  \n\n\nSince version 8 Java has included it\u2019s version of closures, called Lambda\u2019s.  Whilst there aren\u2019t quite as flexible as some of their equivalents on other languages.  All variable access must be to \u2018finals\u2019 for example.  They are sufficient to build an equivalent  testing DSL.  That\u2019s what we decided to do with Ginkgo4j, pronounced Ginkgo for Java.\n\n\nGetting Ginkgo4j\n\n\nAdd the ginkgo4j to your project as a test dependency.  For a maven project add:-\n\n\ndependency\n\n    \ngroupId\ncom.github.paulcwarren\n/groupId\n\n    \nartifactId\nginkgo4j\n/artifactId\n\n    \nversion\n1.0.7\n/version\n\n\n/dependency\n\n\n\n\n\nor for a Gradle project add:-\n\n\ncompile 'com.github.paulcwarren:ginkgo4j:1.0.7'\n\n\nfor other buold systems see \nhere\n.\n\n\nGetting Started: Writing Your First Test\n\n\nBootstrapping a Test\n\n\nIn your Java 8 project, add a new test class called BookTests.java as follows:-\n\n\npackage com.github.paulcwarren.ginkgo4j.examples;\n\nimport static com.github.paulcwarren.ginkgo4j.Ginkgo4jDSL.*;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport org.junit.runner.RunWith;\n\nimport com.github.paulcwarren.ginkgo4j.Ginkgo4jRunner;\n\n@RunWith(Ginkgo4jRunner.class)\npublic class BookTests {\n    {\n        Describe(\nBook\n, () -\n {\n        });\n    }\n}\n\n\n\n\n\nLet\u2019s break this down:\n\n\n\n\nThe imports \nGinkgo4jDSL.\n and \nGinkgo4jRunner* add Ginkgo4j\u2019s DSL and JUnit runner to this class.  The JUnit runner allows these style of tests to be run in all IDEs supporting JUnit and also in build tools such as Ant, Maven and Gradle.\n\n\nThe hamcrest imports add Hamcrest's matcher library that we will use to make assertions in our test. \n\n\nWe add a top-level \nDescribe\n container using Ginkgo4j\u2019s \nDescribe(String title, ExecutableBlock block)\n method.  The top-level braces \n{}\n trick allows us to evaluate the \nDescribe\n at the top level without having to wrap it.  The 2nd argument to the \nDescribe\n \n() -\n {}\n is a lambda expression defining an anonymous class that implements the ExecutableBlock interface.  This lamdba expression will contain our specs.  \n\n\n\n\nAt this point you can run you suite.  In eclipse we right-click on or test class and select \nRun As...-\nJunit test\n.\n\n\n\n\nAdding Specs\n\n\nAn empty test is not very interesting so let\u2019s add some Specs our Book class.\n\n\nprivate Book longBook;\nprivate Book shortBook;\n{\n Describe(\nBook\n, () -\n {\n   BeforeEach(() -\n {\n     longBook = new Book(\nLes Miserables\n, \nVictor Hugo\n, 1488);\n     shortBook = new Book(\nFox In Socks\n, \nDr. Seuss\n, 24);\n   });\n\n   Context(\nCategorizing book length\n, () -\n {\n     Context(\nWith more than 300 pages\n, () -\n {\n       It(\nshould be a novel\n, () -\n {\n         assertThat(longBook.categoryByLength(), is(\nNOVEL\n));\n       });\n     });\n\n     Context(\nWith fewer than 300 pages\n, () -\n {\n       It(\nshould be a short story\n, () -\n {\n         assertThat(shortBook.categoryByLength(), is(\nNOVELLA\n));\n       });\n     });\n   });\n   });\n }\n\n\n\n\nLet\u2019s break this down:\n\n\n\n\nGinkgo4J makes extensive use of lambdas to allow you to build descriptive test suites.\n\n\nYou should make use of \nDescribe\n and \nContext\n containers to expressively organize the behavior of your code.\n\n\nYou can use \nBeforeEach\n to set up state for your specs. You use \nIt\n to specify a single spec.\n\n\nIn order to share state between a \nBeforeEach\n and an \nIt\n you must use member variables.\n\n\nWe use Hamcrest\u2019s assertThat syntax to make expectations on the categoryByLength() method.\nAssuming a Book model with this behavior, running this JUnit test in Eclipse (or Intellij) will yield:\n\n\n\n\n\n\nSuccess!\n\n\nFocussed Specs\n\n\nIt is often convenient, when developing to be able to run a subset of specs. Ginkgo4J allows you to focus individual specs or whole containers of specs programatically by adding an F in front of your \nDescribe\n, \nContext\n, and \nIt\n:\n\n\n FDescribe(\nsome behavior\n, () -\n { ... })\n FContext(\nsome scenario\n, () -\n { ... })\n FIt(\nsome assertion\n, () -\n { ... })\n\n\n\n\ndoing so instructs Ginkgo4J to only run those specs. To run all specs, you\u2019ll need to go back and remove all the Fs.\n\n\nParallel Specs\n\n\nGinkgo4J has support for running specs in parallel.  It does this by spawning separate threads and dividing the specs evenly among these threads.  Parallelism is on by default and will use 4 threads.  If you wish to modify this you can add the additional annotation to your test class:-\n\n\n@Ginkgo4jConfiguration(threads=1)\n\n\n\n\nwhich will instruct Ginkgo4J to run a single thread.\n\n\nSpring Support\n\n\nGinkgo4J also offers native support for Spring.  To test a Spring application context simply replace the \n@RunWith(Ginkgo4jRunner.class)\n with \n@RunWith(Ginkgo4jSpringRunner.class)\n and initialize you test class\u2019 Spring application context in exactly the same way as if you were using Spring\u2019s SpringJUnit4ClassRunner\n\n\n@RunWith(Ginkgo4jSpringRunner.class)\n@SpringApplicationConfiguration(classes = Ginkgo4jSpringApplication.class)\n\npublic class Ginkgo4jSpringApplicationTests {\n  @Autowired\n  HelloService helloService;\n  {\n  Describe(\nSpring intergation\n, () -\n {\n    It(\nshould be able to use spring beans\n, () -\n {\n      assertThat(helloService, is(not(nullValue())));\n    });\n\n    Context(\nhello service\n, () -\n {\n      It(\nshould say hello\n, () -\n {\n        assertThat(helloService.sayHello(\nWorld\n), is(\nHello World!\n));\n      });\n    });\n   });\n   }\n\n   @Test\n   public void noop() {\n   }\n }\n\n\n\n\nThe \nnoop\n test class is currently required as Spring\u2019s JUnit runner requires on at least one method annotated with \n@Test\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#ginkgo4j", 
            "text": "", 
            "title": "Ginkgo4j"
        }, 
        {
            "location": "/#a-java-bdd-testing-framework", 
            "text": "Ginkgo4j  is a BDD-style Java testing framework built to help you efficiently write expressive and comprehensive tests.  Ginkgo4j was inspired by its namesake  Ginkgo .  It mirrors frameworks from other languages like RSpec in Ruby.  All of these framework provide a very simply DSL that the developer can use in his test to build up a described context with closures.    Since version 8 Java has included it\u2019s version of closures, called Lambda\u2019s.  Whilst there aren\u2019t quite as flexible as some of their equivalents on other languages.  All variable access must be to \u2018finals\u2019 for example.  They are sufficient to build an equivalent  testing DSL.  That\u2019s what we decided to do with Ginkgo4j, pronounced Ginkgo for Java.", 
            "title": "A Java BDD Testing Framework"
        }, 
        {
            "location": "/#getting-ginkgo4j", 
            "text": "Add the ginkgo4j to your project as a test dependency.  For a maven project add:-  dependency \n     groupId com.github.paulcwarren /groupId \n     artifactId ginkgo4j /artifactId \n     version 1.0.7 /version  /dependency   or for a Gradle project add:-  compile 'com.github.paulcwarren:ginkgo4j:1.0.7'  for other buold systems see  here .", 
            "title": "Getting Ginkgo4j"
        }, 
        {
            "location": "/#getting-started-writing-your-first-test", 
            "text": "", 
            "title": "Getting Started: Writing Your First Test"
        }, 
        {
            "location": "/#bootstrapping-a-test", 
            "text": "In your Java 8 project, add a new test class called BookTests.java as follows:-  package com.github.paulcwarren.ginkgo4j.examples;\n\nimport static com.github.paulcwarren.ginkgo4j.Ginkgo4jDSL.*;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\nimport org.junit.runner.RunWith;\n\nimport com.github.paulcwarren.ginkgo4j.Ginkgo4jRunner;\n\n@RunWith(Ginkgo4jRunner.class)\npublic class BookTests {\n    {\n        Describe( Book , () -  {\n        });\n    }\n}  Let\u2019s break this down:   The imports  Ginkgo4jDSL.  and  Ginkgo4jRunner* add Ginkgo4j\u2019s DSL and JUnit runner to this class.  The JUnit runner allows these style of tests to be run in all IDEs supporting JUnit and also in build tools such as Ant, Maven and Gradle.  The hamcrest imports add Hamcrest's matcher library that we will use to make assertions in our test.   We add a top-level  Describe  container using Ginkgo4j\u2019s  Describe(String title, ExecutableBlock block)  method.  The top-level braces  {}  trick allows us to evaluate the  Describe  at the top level without having to wrap it.  The 2nd argument to the  Describe   () -  {}  is a lambda expression defining an anonymous class that implements the ExecutableBlock interface.  This lamdba expression will contain our specs.     At this point you can run you suite.  In eclipse we right-click on or test class and select  Run As...- Junit test .", 
            "title": "Bootstrapping a Test"
        }, 
        {
            "location": "/#adding-specs", 
            "text": "An empty test is not very interesting so let\u2019s add some Specs our Book class.  private Book longBook;\nprivate Book shortBook;\n{\n Describe( Book , () -  {\n   BeforeEach(() -  {\n     longBook = new Book( Les Miserables ,  Victor Hugo , 1488);\n     shortBook = new Book( Fox In Socks ,  Dr. Seuss , 24);\n   });\n\n   Context( Categorizing book length , () -  {\n     Context( With more than 300 pages , () -  {\n       It( should be a novel , () -  {\n         assertThat(longBook.categoryByLength(), is( NOVEL ));\n       });\n     });\n\n     Context( With fewer than 300 pages , () -  {\n       It( should be a short story , () -  {\n         assertThat(shortBook.categoryByLength(), is( NOVELLA ));\n       });\n     });\n   });\n   });\n }  Let\u2019s break this down:   Ginkgo4J makes extensive use of lambdas to allow you to build descriptive test suites.  You should make use of  Describe  and  Context  containers to expressively organize the behavior of your code.  You can use  BeforeEach  to set up state for your specs. You use  It  to specify a single spec.  In order to share state between a  BeforeEach  and an  It  you must use member variables.  We use Hamcrest\u2019s assertThat syntax to make expectations on the categoryByLength() method.\nAssuming a Book model with this behavior, running this JUnit test in Eclipse (or Intellij) will yield:    Success!", 
            "title": "Adding Specs"
        }, 
        {
            "location": "/#focussed-specs", 
            "text": "It is often convenient, when developing to be able to run a subset of specs. Ginkgo4J allows you to focus individual specs or whole containers of specs programatically by adding an F in front of your  Describe ,  Context , and  It :   FDescribe( some behavior , () -  { ... })\n FContext( some scenario , () -  { ... })\n FIt( some assertion , () -  { ... })  doing so instructs Ginkgo4J to only run those specs. To run all specs, you\u2019ll need to go back and remove all the Fs.", 
            "title": "Focussed Specs"
        }, 
        {
            "location": "/#parallel-specs", 
            "text": "Ginkgo4J has support for running specs in parallel.  It does this by spawning separate threads and dividing the specs evenly among these threads.  Parallelism is on by default and will use 4 threads.  If you wish to modify this you can add the additional annotation to your test class:-  @Ginkgo4jConfiguration(threads=1)  which will instruct Ginkgo4J to run a single thread.", 
            "title": "Parallel Specs"
        }, 
        {
            "location": "/#spring-support", 
            "text": "Ginkgo4J also offers native support for Spring.  To test a Spring application context simply replace the  @RunWith(Ginkgo4jRunner.class)  with  @RunWith(Ginkgo4jSpringRunner.class)  and initialize you test class\u2019 Spring application context in exactly the same way as if you were using Spring\u2019s SpringJUnit4ClassRunner  @RunWith(Ginkgo4jSpringRunner.class)\n@SpringApplicationConfiguration(classes = Ginkgo4jSpringApplication.class)\n\npublic class Ginkgo4jSpringApplicationTests {\n  @Autowired\n  HelloService helloService;\n  {\n  Describe( Spring intergation , () -  {\n    It( should be able to use spring beans , () -  {\n      assertThat(helloService, is(not(nullValue())));\n    });\n\n    Context( hello service , () -  {\n      It( should say hello , () -  {\n        assertThat(helloService.sayHello( World ), is( Hello World! ));\n      });\n    });\n   });\n   }\n\n   @Test\n   public void noop() {\n   }\n }  The  noop  test class is currently required as Spring\u2019s JUnit runner requires on at least one method annotated with  @Test .", 
            "title": "Spring Support"
        }
    ]
}